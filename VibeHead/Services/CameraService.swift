import AVFoundation
import UIKit
import Combine

class CameraService: NSObject, ObservableObject {
    @Published var authorizationStatus: AVAuthorizationStatus = .notDetermined
    @Published var isSessionRunning = false
    @Published var previewLayer: AVCaptureVideoPreviewLayer?
    @Published var currentFrameRate: Double = 15.0
    
    let captureSession = AVCaptureSession()
    private let sessionQueue = DispatchQueue(label: "camera.session.queue")
    private var videoDeviceInput: AVCaptureDeviceInput?
    private var videoDataOutput: AVCaptureVideoDataOutput?
    private var performanceMonitor: PerformanceMonitorService?
    private var cancellables = Set<AnyCancellable>()
    
    // Frame rate control
    private var targetFrameRate: Double = 15.0
    private var lastFrameTime: CFTimeInterval = 0
    private let frameRateQueue = DispatchQueue(label: "camera.framerate.queue")
    
    // Delegate for processing video frames
    weak var frameDelegate: AVCaptureVideoDataOutputSampleBufferDelegate?
    
    override init() {
        super.init()
        
        // Check if running on simulator
        #if targetEnvironment(simulator)
        print("üé• ‚ö†Ô∏è Running on iOS Simulator - Camera functionality will be limited")
        #else
        print("üé• Running on physical device - Camera should work normally")
        #endif
        
        checkCameraPermission()
        setupCaptureSession()
        setupPerformanceMonitoring()
    }
    
    // MARK: - Performance Monitoring Setup
    
    private func setupPerformanceMonitoring() {
        performanceMonitor = PerformanceMonitorService()
        
        // Monitor performance changes
        performanceMonitor?.$recommendedFrameRate
            .receive(on: DispatchQueue.main)
            .sink { [weak self] newFrameRate in
                self?.updateFrameRate(newFrameRate)
            }
            .store(in: &cancellables)
        
        // Listen for cleanup notifications
        NotificationCenter.default.publisher(for: .performanceCleanupRequired)
            .sink { [weak self] _ in
                self?.performMemoryCleanup()
            }
            .store(in: &cancellables)
    }
    
    private func updateFrameRate(_ newFrameRate: Double) {
        guard newFrameRate != targetFrameRate else { return }
        
        targetFrameRate = newFrameRate
        currentFrameRate = newFrameRate
        
        sessionQueue.async { [weak self] in
            self?.configureFrameRate(newFrameRate)
        }
        
        print("Camera frame rate updated to: \(newFrameRate)fps")
    }
    
    private func configureFrameRate(_ frameRate: Double) {
        guard let device = videoDeviceInput?.device else { return }
        
        do {
            try device.lockForConfiguration()
            
            // Find the best format for the desired frame rate
            let format = device.activeFormat
            let ranges = format.videoSupportedFrameRateRanges
            
            if let range = ranges.first(where: { $0.maxFrameRate >= frameRate }) {
                let clampedFrameRate = min(frameRate, range.maxFrameRate)
                device.activeVideoMinFrameDuration = CMTimeMake(value: 1, timescale: Int32(clampedFrameRate))
                device.activeVideoMaxFrameDuration = CMTimeMake(value: 1, timescale: Int32(clampedFrameRate))
            }
            
            device.unlockForConfiguration()
        } catch {
            print("Error configuring frame rate: \(error)")
        }
    }
    
    private func performMemoryCleanup() {
        sessionQueue.async { [weak self] in
            // Clear any cached frames or buffers
            self?.videoDataOutput?.alwaysDiscardsLateVideoFrames = true
            
            // Force garbage collection
            DispatchQueue.main.async {
                // Trigger memory cleanup
                print("Performing camera service memory cleanup")
            }
        }
    }
    
    // MARK: - Permission Handling
    
    func checkCameraPermission() {
        authorizationStatus = AVCaptureDevice.authorizationStatus(for: .video)
    }
    
    func requestCameraPermission() async -> Bool {
        let status = await AVCaptureDevice.requestAccess(for: .video)
        
        await MainActor.run {
            self.authorizationStatus = AVCaptureDevice.authorizationStatus(for: .video)
            
            // If permission was granted, setup the camera session
            if self.authorizationStatus == .authorized {
                self.setupCameraSessionAfterPermission()
            }
        }
        
        return status
    }
    
    private func setupCameraSessionAfterPermission() {
        sessionQueue.async { [weak self] in
            guard let self = self else { return }
            
            print("üé• Setting up camera session after permission granted...")
            
            self.captureSession.beginConfiguration()
            
            do {
                // Setup video input (front camera)
                try self.setupVideoInput()
                
                // Setup video output
                try self.setupVideoOutput()
                
                self.captureSession.commitConfiguration()
                
                print("üé• Camera session configured successfully after permission granted")
                
                // Á°Æ‰øùÈ¢ÑËßàÂ±ÇËøûÊé•Âà∞Ê≠£Á°ÆÁöÑ‰ºöËØù
                DispatchQueue.main.async {
                    if let previewLayer = self.previewLayer {
                        previewLayer.session = self.captureSession
                        previewLayer.connection?.isEnabled = true
                        print("üé• Preview layer reconnected to session")
                    }
                    
                    // Start preview immediately after configuration
                    self.startPreviewOnly()
                }
            } catch {
                self.captureSession.commitConfiguration()
                self.handleCameraError(error)
            }
        }
    }
    
    func handleCameraPermissionDenied() -> HealthyCodeError {
        return .cameraPermissionDenied
    }
    
    func validateCameraAvailability() throws {
        guard AVCaptureDevice.default(.builtInWideAngleCamera, for: .video, position: .front) != nil else {
            throw HealthyCodeError.cameraNotAvailable
        }
        
        guard authorizationStatus == .authorized else {
            throw HealthyCodeError.cameraPermissionDenied
        }
    }
    
    // MARK: - Session Setup
    
    private func setupCaptureSession() {
        sessionQueue.async { [weak self] in
            self?.configureCaptureSession()
        }
    }
    
    private func configureCaptureSession() {
        // Don't validate camera availability during initial setup
        // This will be checked when starting the session
        
        captureSession.beginConfiguration()
        
        // Configure session preset for optimal performance
        if captureSession.canSetSessionPreset(.medium) {
            captureSession.sessionPreset = .medium
        }
        
        // Always setup preview layer first
        setupPreviewLayer()
        
        // Only setup input/output if we have permission
        if authorizationStatus == .authorized {
            do {
                // Setup video input (front camera)
                try setupVideoInput()
                
                // Setup video output
                try setupVideoOutput()
                
                captureSession.commitConfiguration()
                
                print("üé• Session configured successfully with permission")
                
            } catch {
                captureSession.commitConfiguration()
                handleCameraError(error)
            }
        } else {
            captureSession.commitConfiguration()
            print("üé• Session configured without camera input (no permission yet)")
        }
    }
    
    private func handleCameraError(_ error: Error) {
        let healthyCodeError: HealthyCodeError
        
        if let hcError = error as? HealthyCodeError {
            healthyCodeError = hcError
        } else {
            healthyCodeError = .cameraNotAvailable
        }
        
        DispatchQueue.main.async {
            print("Camera error: \(healthyCodeError.localizedDescription)")
            // Post notification for UI to handle graceful degradation
            NotificationCenter.default.post(
                name: .cameraErrorOccurred,
                object: healthyCodeError
            )
        }
    }
    
    private func setupVideoInput() throws {
        // Remove existing input if any
        if let currentInput = videoDeviceInput {
            captureSession.removeInput(currentInput)
        }
        
        // List all available cameras for debugging
        let discoverySession = AVCaptureDevice.DiscoverySession(
            deviceTypes: [.builtInWideAngleCamera],
            mediaType: .video,
            position: .unspecified
        )
        
        print("üé• Available camera devices:")
        for device in discoverySession.devices {
            print("üé•   - \(device.localizedName) (position: \(device.position.rawValue))")
        }
        
        // Get front camera
        guard let frontCamera = AVCaptureDevice.default(.builtInWideAngleCamera, 
                                                       for: .video, 
                                                       position: .front) else {
            print("üé• ‚ùå No front camera found!")
            
            // Try any available camera as fallback
            if let anyCamera = discoverySession.devices.first {
                print("üé• Using fallback camera: \(anyCamera.localizedName)")
                try setupVideoInputWithDevice(anyCamera)
                return
            }
            
            throw HealthyCodeError.cameraNotAvailable
        }
        
        print("üé• ‚úÖ Using front camera: \(frontCamera.localizedName)")
        try setupVideoInputWithDevice(frontCamera)
    }
    
    private func setupVideoInputWithDevice(_ device: AVCaptureDevice) throws {
        do {
            let videoInput = try AVCaptureDeviceInput(device: device)
            
            guard captureSession.canAddInput(videoInput) else {
                print("üé• ‚ùå Cannot add video input to session")
                throw HealthyCodeError.cameraNotAvailable
            }
            
            captureSession.addInput(videoInput)
            videoDeviceInput = videoInput
            print("üé• ‚úÖ Video input added successfully")
        } catch {
            print("üé• ‚ùå Error creating video input: \(error)")
            if error is HealthyCodeError {
                throw error
            } else {
                throw HealthyCodeError.cameraNotAvailable
            }
        }
    }
    
    private func setupVideoOutput() throws {
        videoDataOutput = AVCaptureVideoDataOutput()
        
        guard let videoOutput = videoDataOutput else {
            throw HealthyCodeError.cameraNotAvailable
        }
        
        // Configure video output settings for optimal performance
        videoOutput.videoSettings = [
            kCVPixelBufferPixelFormatTypeKey as String: kCVPixelFormatType_32BGRA
        ]
        
        // Optimize for performance and battery life
        videoOutput.alwaysDiscardsLateVideoFrames = true
        
        // Set sample buffer delegate with frame rate control
        guard captureSession.canAddOutput(videoOutput) else {
            throw HealthyCodeError.cameraNotAvailable
        }
        
        captureSession.addOutput(videoOutput)
        
        // Set delegate for frame processing with throttling
        let videoQueue = DispatchQueue(label: "camera.video.queue", qos: .userInitiated)
        videoOutput.setSampleBufferDelegate(self, queue: videoQueue)
    }
    
    private func setupPreviewLayer() {
        DispatchQueue.main.async { [weak self] in
            guard let self = self else { return }
            
            let previewLayer = AVCaptureVideoPreviewLayer(session: self.captureSession)
            previewLayer.videoGravity = .resizeAspectFill
            
            // Á°Æ‰øùÈ¢ÑËßàÂ±ÇËøûÊé•Ê≠£Á°Æ
            if let connection = previewLayer.connection {
                if connection.isVideoOrientationSupported {
                    connection.videoOrientation = .portrait
                }
                print("üé• Preview layer connection configured: \(connection.isEnabled)")
            }
            
            self.previewLayer = previewLayer
            
            print("üé• Preview layer created successfully")
            print("üé• Session has inputs: \(self.captureSession.inputs.count)")
            print("üé• Session has outputs: \(self.captureSession.outputs.count)")
            print("üé• Session is running: \(self.captureSession.isRunning)")
            print("üé• Preview layer connection: \(previewLayer.connection?.isEnabled ?? false)")
        }
    }
    
    // MARK: - Session Control
    
    func startPreviewOnly() {
        print("üé• Starting preview only...")
        
        // Start session for preview only, without validation
        sessionQueue.async { [weak self] in
            guard let self = self else { return }
            
            print("üé• Session queue: checking if session is running: \(self.captureSession.isRunning)")
            print("üé• Session inputs: \(self.captureSession.inputs.count)")
            print("üé• Session outputs: \(self.captureSession.outputs.count)")
            
            // Á°Æ‰øù‰ºöËØùÈÖçÁΩÆÊ≠£Á°Æ
            if self.captureSession.inputs.isEmpty && self.authorizationStatus == .authorized {
                print("üé• No inputs found, reconfiguring session...")
                self.configureCaptureSession()
            }
            
            if !self.captureSession.isRunning {
                print("üé• Starting capture session...")
                self.captureSession.startRunning()
                
                // Á≠âÂæÖ‰∏ÄÂ∞èÊÆµÊó∂Èó¥Á°Æ‰øù‰ºöËØùÂÆåÂÖ®ÂêØÂä®
                DispatchQueue.main.asyncAfter(deadline: .now() + 0.5) {
                    self.isSessionRunning = self.captureSession.isRunning
                    print("üé• Camera preview session started: \(self.isSessionRunning)")
                    
                    if self.isSessionRunning {
                        print("üé• ‚úÖ Session is now running successfully!")
                        
                        // Âº∫Âà∂Êõ¥Êñ∞È¢ÑËßàÂ±Ç
                        if let previewLayer = self.previewLayer {
                            print("üé• Refreshing preview layer connection...")
                            previewLayer.connection?.isEnabled = true
                        }
                    } else {
                        print("üé• ‚ùå Session failed to start!")
                        // Â∞ùËØïÈáçÊñ∞ÈÖçÁΩÆ
                        self.sessionQueue.async {
                            self.reconfigureSession()
                        }
                    }
                }
            } else {
                print("üé• Session was already running")
                DispatchQueue.main.async {
                    self.isSessionRunning = true
                }
            }
        }
    }
    
    private func reconfigureSession() {
        print("üé• Attempting to reconfigure session...")
        
        captureSession.beginConfiguration()
        
        // ÁßªÈô§ÊâÄÊúâÁé∞ÊúâÁöÑËæìÂÖ•ÂíåËæìÂá∫
        for input in captureSession.inputs {
            captureSession.removeInput(input)
        }
        for output in captureSession.outputs {
            captureSession.removeOutput(output)
        }
        
        do {
            // ÈáçÊñ∞ËÆæÁΩÆËæìÂÖ•ÂíåËæìÂá∫
            try setupVideoInput()
            try setupVideoOutput()
            
            captureSession.commitConfiguration()
            
            print("üé• Session reconfigured successfully")
            
            // ÈáçÊñ∞ÂêØÂä®‰ºöËØù
            if !captureSession.isRunning {
                captureSession.startRunning()
            }
            
        } catch {
            captureSession.commitConfiguration()
            print("üé• Failed to reconfigure session: \(error)")
        }
    }
    
    func startSession() {
        do {
            try validateCameraAvailability()
        } catch {
            handleCameraError(error)
            return
        }
        
        sessionQueue.async { [weak self] in
            guard let self = self else { return }
            
            if !self.captureSession.isRunning {
                self.captureSession.startRunning()
                
                DispatchQueue.main.async {
                    self.isSessionRunning = self.captureSession.isRunning
                    
                    // Verify session actually started
                    if !self.isSessionRunning {
                        self.handleCameraError(HealthyCodeError.cameraNotAvailable)
                    }
                }
            }
        }
    }
    
    func stopSession() {
        sessionQueue.async { [weak self] in
            guard let self = self else { return }
            
            if self.captureSession.isRunning {
                self.captureSession.stopRunning()
                
                DispatchQueue.main.async {
                    self.isSessionRunning = false
                }
            }
        }
    }
    
    // MARK: - Frame Delegate Management
    
    func setFrameDelegate(_ delegate: AVCaptureVideoDataOutputSampleBufferDelegate?) {
        frameDelegate = delegate
    }
    
    // MARK: - Frame Rate Control
    
    private func shouldProcessFrame() -> Bool {
        let currentTime = CACurrentMediaTime()
        let targetInterval = 1.0 / targetFrameRate
        
        if currentTime - lastFrameTime >= targetInterval {
            lastFrameTime = currentTime
            return true
        }
        
        return false
    }
    
    func getCurrentPerformanceSettings() -> PerformanceSettings? {
        return performanceMonitor?.optimizeForCurrentConditions()
    }
    
    // MARK: - Debug Methods
    
    func debugCameraStatus() {
        print("üé• === Camera Debug Status ===")
        print("üé• Authorization Status: \(authorizationStatus.localizedDescription)")
        print("üé• Session Running: \(captureSession.isRunning)")
        print("üé• Session Inputs: \(captureSession.inputs.count)")
        print("üé• Session Outputs: \(captureSession.outputs.count)")
        print("üé• Preview Layer: \(previewLayer != nil ? "‚úÖ" : "‚ùå")")
        
        if let previewLayer = previewLayer {
            print("üé• Preview Layer Session: \(previewLayer.session === captureSession ? "‚úÖ" : "‚ùå")")
            print("üé• Preview Layer Connection: \(previewLayer.connection?.isEnabled ?? false ? "‚úÖ" : "‚ùå")")
            print("üé• Preview Layer Frame: \(previewLayer.frame)")
        }
        
        // Ê£ÄÊü•ËæìÂÖ•ËÆæÂ§á
        for input in captureSession.inputs {
            if let deviceInput = input as? AVCaptureDeviceInput {
                print("üé• Input Device: \(deviceInput.device.localizedName)")
                print("üé• Input Device Position: \(deviceInput.device.position.rawValue)")
            }
        }
        
        print("üé• === End Debug Status ===")
    }
    
    func restartCameraSession() {
        print("üé• Manually restarting camera session...")
        
        sessionQueue.async { [weak self] in
            guard let self = self else { return }
            
            if self.captureSession.isRunning {
                self.captureSession.stopRunning()
            }
            
            // Á≠âÂæÖ‰∏Ä‰∏ãÂÜçÈáçÂêØ
            DispatchQueue.main.asyncAfter(deadline: .now() + 0.5) {
                self.sessionQueue.async {
                    self.captureSession.startRunning()
                    
                    DispatchQueue.main.async {
                        self.isSessionRunning = self.captureSession.isRunning
                        print("üé• Manual restart result: \(self.isSessionRunning)")
                        
                        // Âº∫Âà∂Âà∑Êñ∞È¢ÑËßàÂ±Ç
                        if let previewLayer = self.previewLayer {
                            previewLayer.connection?.isEnabled = true
                        }
                    }
                }
            }
        }
    }
}

// MARK: - AVCaptureVideoDataOutputSampleBufferDelegate

extension CameraService: AVCaptureVideoDataOutputSampleBufferDelegate {
    func captureOutput(_ output: AVCaptureOutput, 
                      didOutput sampleBuffer: CMSampleBuffer, 
                      from connection: AVCaptureConnection) {
        
        // Apply frame rate throttling
        guard shouldProcessFrame() else { return }
        
        // Update performance monitor
        performanceMonitor?.updateCurrentFrameRate(currentFrameRate)
        
        // Forward to the actual frame delegate
        frameDelegate?.captureOutput?(output, didOutput: sampleBuffer, from: connection)
    }
    
    func captureOutput(_ output: AVCaptureOutput, 
                      didDrop sampleBuffer: CMSampleBuffer, 
                      from connection: AVCaptureConnection) {
        // Handle dropped frames
        if let delegate = frameDelegate {
            delegate.captureOutput?(output, didDrop: sampleBuffer, from: connection)
        }
    }
}

// MARK: - Camera Permission Status Extension

extension AVAuthorizationStatus {
    var isAuthorized: Bool {
        return self == .authorized
    }
    
    var isDenied: Bool {
        return self == .denied || self == .restricted
    }
    
    var localizedDescription: String {
        switch self {
        case .authorized:
            return "Â∑≤ÊéàÊùÉ"
        case .denied:
            return "Â∑≤ÊãíÁªù"
        case .restricted:
            return "ÂèóÈôêÂà∂"
        case .notDetermined:
            return "Êú™Á°ÆÂÆö"
        @unknown default:
            return "Êú™Áü•Áä∂ÊÄÅ"
        }
    }
}

// MARK: - Notification Extensions

extension Notification.Name {
    static let cameraErrorOccurred = Notification.Name("cameraErrorOccurred")
}